import logging
import tempfile
import subprocess
import threading
import io
import os
import tarfile
from Bio import SeqIO
from Bio.Phylo import BaseTree
from nbitk.Phylo.BOLDXLSXIO import Parser as BOLDParser
from nbitk.Phylo.NCBITaxdmp import Parser as NCBIParser
from nbitk.Taxon import Taxon


def get_tip_by_processid(process_id, tree):
    """
    Get a tip from the BOLD tree by its 'processid' attribute.
    :param process_id: A process ID
    :param tree: The BOLD tree
    :return: A Taxon object
    """
    logging.info(f'Looking up tip by process ID: {process_id}')
    for tip in tree.get_terminals():
        if process_id in tip.guids:
            return tip
    return None


def build_constraint(bold_tip: Taxon, bold_tree: BaseTree, ncbi_tree: BaseTree, constraint_level: str) -> str:
    """
    Given a tip from the BOLD tree, looks up its path to the root, fetching the interior node
    at the specified taxonomic rank. Then, traverses the NCBI tree to find the corresponding
    node at the same rank. From there, all terminal descendants of the NCBI node are collected
    and their taxids are returned as a set.
    :param bold_tip: A Taxon object from the BOLD tree
    :param bold_tree: A BaseTree object created by BOLDParser()
    :param ncbi_tree: A BaseTree object created by NCBIParser()
    :param constraint_level: A taxonomic rank to constrain the search to
    :return: An NCBI taxon ID
    """

    # Find the node at the specified taxonomic rank in the BOLD lineage that subtends the tip
    logging.info(f"Going to traverse BOLD taxonomy for the {constraint_level} to which {bold_tip} belongs")
    bold_anc = next(node for node in bold_tree.root.get_path(bold_tip) if node.taxonomic_rank == constraint_level)
    logging.info(f"BOLD {bold_tip.taxonomic_rank} {bold_tip.name} is member of {constraint_level} {bold_anc.name}")

    # Find the corresponding node at the same rank in the NCBI tree
    ncbi_anc = next(node for node in ncbi_tree.get_nonterminals()
                    if node.name == bold_anc.name and node.taxonomic_rank == constraint_level)

    # Return or die
    if ncbi_anc:
        logging.info(f"Corresponding ncbi node is taxon:{ncbi_anc.guids['taxon']}")
        return ncbi_anc.guids['taxon']
    else:
        raise ValueError(f"Could not find NCBI node for BOLD node '{bold_anc}'")


def read_bold_taxonomy(spreadsheet):
    """
    Read a BOLD taxonomy spreadsheet. This is a file that is generated by the BOLD workbench and contains taxonomic
    information for a set of sequences. The file must contain two tabs: 'Lab Sheet' and 'Taxonomy'. The 'Lab Sheet' tab
    must contain two columns: 'Sample ID' and 'Process ID'. The 'Taxonomy' tab must contain columns for the taxonomic
    ranks (Phylum, Class, Order, Family, Subfamily, Tribe, Genus, Species, Subspecies). The parser will create a tree
    with the taxonomic ranks as nodes and the sample IDs as leaves. The tree will be returned as a BaseTree object but
    its nodes will be Taxon objects. The terminal Taxon nodes will have a 'processid' field in the guid attribute that
    maps to the 'Process ID' column in the 'Lab Sheet' tab.
    :param spreadsheet: A path to the BOLD taxonomy spreadsheet
    :return: A BaseTree object with Taxon nodes
    """
    # Read the Excel file into a BytesIO object
    logging.info(f"Reading BOLD taxonomy from {spreadsheet}")
    with open(spreadsheet, 'rb') as file:
        excel_data = io.BytesIO(file.read())

    # Pass the BytesIO object to BOLDParser
    return BOLDParser(excel_data).parse()


def read_ncbi_taxonomy(taxdump):
    """
    Read the NCBI taxonomy from a taxdump file. This is a tarball that contains two files: nodes.dmp and names.dmp.
    The nodes.dmp file contains the taxonomic tree structure, while the names.dmp file contains the taxon names.
    The nodes will have a 'taxon' field in the guid attribute that maps to the NCBI taxon ID.
    :param taxdump: A path to the taxdump tarball
    :return: A BaseTree object with Taxon nodes
    """
    logging.info(f"Reading NCBI taxonomy from {taxdump}")
    tar = tarfile.open(taxdump, "r:gz")
    return NCBIParser(tar).parse()


def _log_output(stream, log_level, processid):
    """
    Log the output of a subprocess to the logger at the specified level.
    :param stream: A stream object
    :param log_level: A logging level
    :param processid: A process ID
    :return:
    """
    for msg in stream:
        msg = msg.strip()
        if msg:
            logging.log(log_level, f"BLASTN output for {processid}: {msg}")


def run_localblast(sequence, ncbi_tree, bold_tree, config):
    """
    Run a local BLASTN search against a local database and return the taxonomic lineages of the hits.
    :param sequence: A Bio.SeqRecord object
    :param ncbi_tree: A Bio.Phylo.BaseTree object created by NCBIParser()
    :param bold_tree: A Bio.Phylo.BaseTree object created by BOLDParser()
    :param config: A Config object
    :return: A list of distinct higher taxa at the specified rank
    """
    logging.info("Running local BLASTN...")
    level = config.get('constrain')

    # Check if there is a sequence
    if len(sequence.seq) == 0:
        return None

    # Create a temporary file for the input sequence
    with tempfile.NamedTemporaryFile(mode='w+', delete=False, suffix='.fasta') as temp_input:
        SeqIO.write(sequence, temp_input, "fasta")
        temp_input_name = temp_input.name

    # Lookup the higher level taxon to limit the search to
    constraint = build_constraint(get_tip_by_processid(sequence.id, bold_tree), bold_tree, ncbi_tree, level)

    # Specify the output file name, as blast TSV (see -outfmt option)
    blast_result = f"{temp_input_name}.tsv"

    # Run local BLASTN
    os.environ['BLASTDB_LMDB_MAP_SIZE'] = str(config.get('BLASTDB_LMDB_MAP_SIZE'))
    os.environ['BLASTDB'] = str(config.get('BLASTDB'))
    try:
        outfmt = "6 qseqid sseqid pident length qstart qend sstart send evalue bitscore staxids"
        process = subprocess.Popen(['blastn',
                                    '-db', str(config.get('blast_db')),
                                    '-num_threads', str(config.get('num_threads')),
                                    '-evalue', str(config.get('evalue')),
                                    '-max_target_seqs', str(config.get('max_target_seqs')),
                                    '-word_size', str(config.get('word_size')),
                                    '-query', temp_input_name,
                                    '-taxids', constraint,
                                    '-task', 'megablast',
                                    '-outfmt', outfmt,
                                    '-out', blast_result
                                    ], stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True)

        # Start threads to handle stdout and stderr and wait for the process to complete
        threading.Thread(target=_log_output, args=(process.stdout, logging.INFO, sequence.id)).start()
        threading.Thread(target=_log_output, args=(process.stderr, logging.ERROR, sequence.id)).start()
        return_code = process.wait()
        if return_code != 0:
            raise subprocess.CalledProcessError(return_code, 'blastn')
        return parse_blast_result(blast_result, ncbi_tree, config)

    # Handle exception
    except subprocess.CalledProcessError as e:
        logging.error(f"Error running local BLASTN: {e}")
        raise


def parse_blast_result(blast_result, tree, config):
    """
    Parse the BLAST result file and return the distinct higher taxa that sit at the configured taxonomic level.
    :param blast_result: A path to the BLAST result file
    :param tree: A Bio.Phylo.BaseTree object created by NCBIParser()
    :param config: A Config object
    :return: A list of distinct higher taxa at the specified rank
    """
    # Parse BLAST result
    distinct_taxids = set()
    with open(blast_result, 'r') as file:
        for line in file:
            columns = line.strip().split('\t')
            if columns:
                taxid_field = columns[-1]
                taxids = taxid_field.split(';')
                distinct_taxids.update(taxid.strip() for taxid in taxids if taxid.strip())
    logging.info(f'{len(distinct_taxids)} distinct taxids found in BLAST result')
    logging.debug(distinct_taxids)
    return collect_higher_taxa(distinct_taxids, tree, config)


def collect_higher_taxa(taxids, tree, config):
    """
    Collect the distinct higher taxa that sit at the configured taxonomic level for an input set of NCBI taxids. For
    example, if the taxonomic level is 'family', the function will return a list of distinct families that are
    encountered in the traversal of the tree from the tips with the specified taxids to the root.
    :param taxids: A set of NCBI taxids
    :param tree: A Bio.Phylo.BaseTree object created by NCBIParser()
    :param config: A Config object
    :return: A list of distinct higher taxa at the specified rank
    """
    tips = []

    # Iterate over all tips in the NCBI taxonomy tree
    # to collect all tips with the specified taxids
    for tip in tree.get_terminals():
        taxid = tip.guids['taxon']

        # Focal tip is annotated with an NCBI taxon ID in the provided lists
        if taxid in taxids:
            tips.append(tip)
            logging.debug(f'Found tip {tip.name} with taxid {taxid}')
    logging.info(f'Found {len(tips)} tips for {len(taxids)} in the tree')

    # Iterate over the collected tips to find their lineages to build a set
    # of distinct higher taxa with the specified rank
    taxa = []
    for tip in tips:
        for node in tree.root.get_path(tip):
            logging.debug(f'Traversing {node} from lineage {tip}')
            if node.taxonomic_rank == str(config.get('level')).lower():
                if node not in taxa:  # Check for uniqueness
                    taxa.append(node)
                    logging.info(f"Found ancestor '{node}' for '{tip}'")
    logging.info(f'Collected {len(taxa)} higher taxa')
    return list(taxa)
